*********************************************************************
*********************************************************************
****************не много основных команд*******************
*********************************************************************
*********************************************************************
обновление системы
	yum update
	**************

выключить linux  
	sudo shutdown -h now
	**************************
создать папку test в текушей директории
	mkdir test
	************
удалить папку в текушей директории(для папок указать опцию -r(рекурсивно) без этой опции не удаляет папки)
	rm -r test
	************
создать пустой файл с именем test в текушей директории
	touch test
	************
удалить файл с именем test из текушей директории
	rm test
	*********

узнать размер папки\файла по адресу /etc/sysconfig
	du -hsx /etc/sysconfig/
	****************************
копировать папку test (-r рекурсивно) из текушей директории в директорию /home/stiks17/
	cp -r test /home/stiks17/ 
	*******************************

поиск "-name" по имени файла с названием 'messages'
	find / -name messages
	****************************
команду TAIL, она позволяет выводить заданное количество строк с конца файла, а также выводить новые строки в интерактивном режиме
просмотров логов из файла 'messages'(по умолчанию выводит последние 10)
	 tail /var/log/messages
	*****************************
то же что и выше но вывести 20 последних событий(меняя ключ можно вывести сколько угодно)
	tail -20 /var/log/messages
	*********************************
Команда HEAD выводит начальные строки (по умолчанию — 10)
просмотров логов из файла 'messages'(по умолчанию выводит первые 10)
	head /var/log/messages
	*****************************
то же что и выше но вывести 20 первых событий(меняя ключ можно вывести сколько угодно)
	head -20 /var/log/messages
	*********************************
поиск текста в файлах linux команда GREP(пишется маленкими буквами)
выведем логи службы  kdump.service
ниже мы попросили вывести строки содержашие "kdump.service" из файла с адресом /var/log/messages
	grep kdump.service /var/log/messages
	************************************************
РЕКУРСИВНОЕ ИСПОЛЬЗОВАНИЕ GREP
ниже мы попросили найти текст "user" во всей папке etc рекурсивно
	grep -r user /etc
	******************** 
совмешение команд знак '|'
в примере ниже мы попросили найти последних 1000 строк в файле 'messages' и потом отобрали те которые содержут 'kdump.service' Это очень обширная тема!
	tail -1000 messages | grep kdump.service
	***************************************************
что бы проверить как разбиты жесткие диски и сколько на них использованного и свободного места воспользуемся командой
	df -h
	******

что бы просмотреть состояние оперативной памяти
	top
	****
что бы посмотреть запушенные процессы вводим
	ps aux
	********
что бы в запущенных процессах найти какой то конкретный(например "cron") введем конструкцию
	ps aux | grep cron
	*********************
что бы остановить('убить') процесс сначала узнаем его номер pid (это видно в команде ps aux) (например 654) и выполним команду
	kill 654
	*********






*********************************************************************
*********************************************************************
***********************сетевые настройки**********************
*********************************************************************
*********************************************************************
здесь лежат сетевые настройки сетевых интерфейсов (аналог подключения по локальной сети так как работаем в вирт машине)*
	/etc/sysconfig/network-scripts
	**************************************

ниже примерное содержание файла fcfg-enp0s3 который содержит сетевые настройки
BOOTPROTO=static
IPADDR=192.168.42.139
NETMASK=255.255.255.0
DNS1=8.8.8.8
DNS2=8.8.4.4
GATEWAY=192.168.42.129
NAME=enp0s3
UUID=60c88b91-5af8-4c0a-8b80-4b757cee0202
DEVICE=enp0s3
ONBOOT=yes

перезагрузить сетевые службы без reboot
	service network restart
	****************************

Текущие адреса dns сервера в CentOS можно посмотреть в двух местах:
В файле с настройками сетевой карты ifcfg-eth0, которым мы ранее неоднократно редактировали.
В файле /etc/resolv.conf
Зачем они сейчас в двух местах, я не знаю, но раньше настройки dns сервера в каких-то дистрибутивах, не помню уже точно каких, указывались только в resolv.conf, но в какой-то момент это изменилось. И все сетевые настройки стали храниться в одном файле вместе с адресом, шлюзом, маской и прочим. Если сейчас отредактировать файл resolv.conf и внести туда какие-то dns сервера, то после перезагрузки они будут заменены на значения из файла ifcfg-eth0(название примерно такое. у меня ifcfg-enp0s3).
Так что для того, чтобы установить параметры dns сервера, нужно отредактировать файл сетевых настроек ifcfg-eth0, добавив туда столько серверов, сколько требуется. Например так:
	 /etc/resolv.conf
	*********************
	/etc/sysconfig/network-scripts/ifcfg-eth0
	***************************************************




*********************************************************************
*********************************************************************
****************заведение пользователей********************
*********************************************************************
*********************************************************************
для обеспечения первоночальной безопасности системы нужно решить две задачи
1.Создать нового пользователя
2.Закрыть удаленный доступ пользователю root 

создать нового пользователя  c именем netskills
	useradd netskills
	********************

для того что бы пользователь netskills мог конфигурировать систему его нужно добавить в список пользователей которым разрешено выполнять операции от имени администратора. Этот список содержится в файле 
	/etc/sudoers
	****************

для его редактированиясушествует специальная команда
	visudo -f /etc/sudoers
	*************************** 

можно и другим редактором. Находим строку
	root	ALL=(ALL)	ALL
	***************************************

и делаем по ее подобию
	netskills	ALL=(ALL)	ALL
	***************************************
вся эта фигня с файлом sudoers не работает!!!
-----------------------------------------------------------

сработала команда добавления пользователя в группу whell(эта группа и дает право на конфигурирование от имени root через команду sudo)
	usermod -aG wheel netskills
	***********************************
после этой команды пользователь получает права root но  в  файле sudoers ни чего не меняется
все группы можно посмотреть в файле
	/etc/group
	**************
там (в данном примере) есть строчка 
	whell:x:10:netskills
	************************
что бы удалить пользователя netskills из группы whell введем
	sudo gpasswd -d netskills wheel
	****************************************

после того как netskills получил возможность конфигурить систему закроем удаленный доступ пользователю root. Для этого сначала перезайдем от netskills
	su netskills
	**************
откроем файл для редактирования(в данном примере пользуюсь редактором mcedit).И обязательно воспользуемся данными нам правами суперпользователя. Для этого сначала используем команду sudo
	sudo mcedit /etc/ssh/sshd_config
	******************************************
находим в нем строчку
	#PermitRootLogin  yes
	***************************
и делаем ее вот такой(раскоментировали и вместо yes написали -no)
	PermitRootLogin  no
	*************************
для вступления в силу изменений перечетаем(перезагрузим) конф. файл командой
	sudo service sshd reload
	******************************

теперь поменяем владельца и группу для папки (надо находиться там же где и папка backap)(-R рекурсивно для всего что внутри -тоже сработает)
	sudo -R chown netskills:netskills backap
	*************************************************

зададим права папке backap(путь абсолютный), -R(для всего вложенного (рекурсивно)): для владельца и группы чтение, запись, выполнение - разрешены для всех  остальных все запрещенно ((rwxrwx---)(770))
	 chmod -R 770 /home/stiks17/backap/
	***********************************************







*********************************************************************
*********************************************************************
**********************установка пакетов************************
*********************************************************************
*********************************************************************
YUM ( Yellowdog Updater Modified ) - это пакетный менеджер с открытым исходным кодом, разработанный в компании RedHat для работы с пакетами в формате RPM. С помощью него пользователи и системные администраторы могут устанавливать, удалять и обновлять пакеты в системах, основанных на RedHat.
Конфигурационный файл yum лежит по адрессу:
	/etc/yum.conf
	******************
Если, например, нужно прописать прокси и.т.п, то нам в этот файл.

Настройки репозиториев лежат в папке 
	/etc/yum.repos.d/
	**********************
если открыть файл /etc/yum.repos.d/CentOS-Base.repo то увидим четыре раздела:
	[base]
	[updates]
	[extras]
	[centosplus]
если в конце раздела видим строчку enabled=0 значит этот раздел выключен.
Зайдем еше в файл CentOS-Media.repo здесь источник диск. Если нам установка с диска не нужна (в большинстве серверов), то он должен быть выключен.Там всего один раздел :
	[c7-media]
и он должен быть выключен
	enabled=0 

Для обновления системы введем от имени админа(sudo)
	yum update
и подтверждаем (y) чтобы согласиться с обновлением. В зависимости от обновления нужно подтверждать один или более раз. В конце напишет Complete!

для установки программ используем
	sudo yum install nano
	**************************
'sudo'-от имени одминистратора, 'yum'-используя пакетный менеджер yum, 'install'-установим, 'nano'-программу текстовый редактор nano

иногда нужная программа входит в какой то пакет программ. Например если попросить установить
	ifconfig, 
для этого наберем 
	yum install ifconfig
то получим ответ (сначала утилита yum поишет его)
	No package ifconfig available
когда такой ответ то вероятно что ifconfig входит вкакойто пакет программ что бы узнать в какой наберем:	
	yum provides ifconfig
	**************************
после выполнения некоторых операций получим ответ.(желательно выполнять с sudo, без sudo может ошибиться и не найти) Гдето в конце ответного вывода(в данном примере 4 с конца строчка) увидим строку
	net-tools-2.0-0.25.20131004git.el7.x86_64 : Basic networking tools
	***********************************************************************************
из этой строчки видно что нам нужен net-tools, соответственно набираем
	yum install net-tools
	**************************
и в конце получаем Complete!







*********************************************************************
*********************************************************************
**********************Межсетевой экран************************
*********************************************************************
*********************************************************************
в разделе сетевые настройки показанна настройка сети через конфигурационные файлы. 
Теперь настроим еще  три септевых подключения через NETWORK MANAGER

информация про сетевые адаптеры и др. можно посмотреть командой
	ifconfig
	*********

ntgthm посмотрим какие интерфейсы видит network nanager
	sudo nmcli d
	****************
увидим примерно такой ответ:
DEVICE   TYPE      STATE      CONNECTION
enp0s3   ethernet  connected  enp0s3
enp0s10  ethernet  connected  ethernet-enp0s10
enp0s8   ethernet  connected  ethernet-enp0s8
enp0s9   ethernet  connected   
lo       loopback  unmanaged  --
на примере enp0s9 мы видим что сетевая карточка есть а подключение на ней отсутствует. На всех остольных подключение настроено и имеет соответствующее название(например сетевая карточка enp0s10 имеет название подключения ethernet-enp0s10)

теперь настроим новые подключения к сетевым картам которые увидели командой sudo nmcli d. 
	sudo nmcli с add type ethernet con-name ethernet-enp0s9 ifname enp0s9 ip4 192.168.250.1/24
	*********************************************************************************************************************
--с add type ethernet --добавить ethernet-соединение с именем ethernet-enp0s9 на сетевую карточку(интепфейс) ifname  с именем enp0s9 и присвоить ip адресс ip4  192.168.250.1/24 с маской /24(255.255.255.0).

теперь подключим соединение
	sudo nmcli device connect enp0s9
	*****************************************

а что бы отключить соединение
	sudo nmcli device disconnect enp0s9
	********************************************

более короткие варианты
 	sudo nmcli device c enp0s9
	*********************************
	udo nmcli device d enp0s9
	*********************************
===================================================================================
-A - добавить правило в цепочку;
-С - проверить все правила;
-D - удалить правило;
-I - вставить правило с нужным номером;
-L - вывести все правила в текущей цепочке;
-S - вывести все правила;
-F - очистить все правила;
-N - создать цепочку;
-X - удалить цепочку;
-P - установить действие по умолчанию.

Дополнительные опции для правил:
-p - указать протокол, один из tcp, udp, udplite, icmp, icmpv6,esp, ah, sctp,
mh;
-s - указать ip адрес устройства-отправителя пакета;
-d - указать ip адрес получателя;
-i - входной сетевой интерфейс;
-o - исходящий сетевой интерфейс;
-j - выбрать действие, если правило подошло
=======================================================================================
чтобы посмотреть состояние фаервола нужно ввевти команду
	sudo iptables -L -v -n
	**************************

чтобы очистить все правила(пропускать все, после перезагрузки восстановится) нибираем
	sudo iptables -F	
	*******************
должны увидеть примерно такое
Chain INPUT (policy ACCEPT 9 packets, 724 bytes)
 pkts bytes target     prot opt in     out     source               destination 

Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)
 pkts bytes target     prot opt in     out     source               destination 

Chain OUTPUT (policy ACCEPT 5 packets, 644 bytes)
 pkts bytes target     prot opt in     out     source               destination 

установить утилиту для iptables
	sudo yum install iptables-servises
	*****************************************

что бы разрешить маршрутизацию отредактируем файл по адресу sysctl.conf
	sudo nano /etc/sysctl.conf
	*********************************
добавим в него следующую строчку в самый низ
	net.ipv4.ip_forward = 1
	****************************
на данный момент в этом файле абсолютно все закоментированно кроме этой строки (которую ввели сами выше)
что бы изименения вступили в силу перезагруим сервак
	sudo reboot
	**************

разрешим локальный трафик для петлевого интерфейса loopback
	sudo iptables -A INPUT -i lo -j ACCEPT
	**********************************************
	sudo iptables -A OUTPUT -o lo -j ACCEPT
	**************************************************
	ключ -A
 -чтобы добавить правило в конец нужной нам цепочки; 
	INPUT и OUTPUT сами цепочки; 
(чаще всего приходится работать  с таблицей FILTER). В этих двух строчках(правилах) мы не указали таблицу, и по умолчанию написанное нами правило попадает в таблицу FILTER(таблица FILTER нужна для фильтрации пакетов). После цепочки мы указали 
	название интерфейса lo 
(интерфейсы можно посмотреть командой IFCONFIG) через который будет проходить трафик, перед названием интерфейса 
	ключ -i 
- интерфейс для входящего трафика. 
	ключ -o
- интерфейс для исходящего трафика.
В FILTER есть три цепочки - INPUT, OUTPUT и FORWARD. Для loopback интерфейса цепочка FORWARD не нужна(loopback интерфейс нужен для работы протоколов внутри одного компьютера (хоста))
	-j
-посредством этого ключа мы указали действие которое необходимо применить к пакетам которые подподают под это правило
	-ACCEPT
-действие (пропустить пакеты которые подподают под наше правило)
	Теперь посмотрим на наше правило. Для начала сохраним правило в файл. Для этого зайдем под root (не смотря на то что выше мы запрешали заход под рутом(этот механизм не плохо бы уточнить)). Для захода под root 
	su
	***
и потом попросит пароль от root
Введем команду для сохранения правила в файл
	iptables-save > /etc/sysconfig/iptables
	************************************************
выходим из под рута (можно быстровыйти сочетанием клавиш ctrl+d)
посмотрим сохраненный файл
	sudo nano /etc/sysconfig/iptables
	******************************************
вот этот файл:
# Generated by iptables-save v1.4.21 on Thu Oct 27 16:43:02 2022
*filter
:INPUT ACCEPT [4:368]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [3:444]
-A INPUT -i lo -j ACCEPT
-A OUTPUT -o lo -j ACCEPT
COMMIT
# Completed on Thu Oct 27 16:43:02 2022

	*filter
-это таблица

	:INPUT ACCEPT [4:368]
	:FORWARD ACCEPT [0:0]
	:OUTPUT ACCEPT [3:444]
-тут указаны цепочки и их политики. В данном файле у всех цепочек по умолчанию стоит политика ACCEPT(пропустить все пакеты не подподающие под правила)

разрешим самому серверу выходить в интернет
	sudo iptables -A OUTPUT -o enp0s3 -j ACCEPT
	********************************************************
-чтобы добавить правило в конец нужной нам цепочки используем	
	ключ -A
 
данным правилом мы разрешаем исходяшие соединения с нашего сервера - из этого следует что используем цепочку 
	OUTPUT

интерфейс нужен для исходящего трафика значит он указывается через ключ 
	-o

сам интерфейс нужен - который смотрит в сторону интернета (внешний порт) у нас это
	enp0s3
	
посредством этого ключа(этот ключ говорит 'добавим правило(точнее политику)')
	-j
 мы указали действие которое необходимо применить к пакетам которые подподают под это правило
	-ACCEPT


разрешим отправлять и принимать пинги на нашем сервере. За пинги отвечает протокол ICMP
	sudo iptables -A INPUT -p icmp -j ACCEPT
	***************************************************
-чтобы добавить правило в конец нужной нам цепочки используем	
	ключ -A
данным правилом мы разрешаем всем пинговать наш сервер - из этого следует что используем цепочку 
	INPUT
разрешаем протокол- поэтому ключ 
	-p
название протокола icmp - поэтому в правило так и пишем
	icmp
а за этим ключом идет название действия, что делать с попадающими под правило пакетами
	-j
accept означает пропустить
	-ACCEPT

а эти правилом разрешим пакетам icmp уходить с нашего сервера т.е. пинговать другие узлы нашему серверу
	sudo iptables -A OUTPUT -p icmp -j ACCEPT
	*****************************************************
расшифровка этого правила такая же как и при правеле выше только OUTPUT вместо INPUT. 

В пределах iptables, соединение может иметь одно из 4-х базовых состояний: NEW, ESTABLISHED, RELATED и INVALID.Что-бы работать с соединениями нам нужно воспользоваться механизмом определения состояний(conntrack) Следушим правилам разрешим прохождение пакетов для уже установленных(ESTABLISHED) или связанных(RELATED) сессий что бы не было лишних проблем.  
	sudo iptables -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
	**************************************************************************************************
правило определяется для цепочки INPUT. т.е. для трафика идушего к нашему серверу
	INPUT

этот ключ задает условие	
	-m

это говорит то что мы пользуемся в данном правиле механизмом определения состояний
	conntrack

это ключ что-бы обозначить какие состояния нас интересуют
	--ctstate

ну и сами состояния
	RELATED, ESTABLISHED

и как нам уже знакомый ключ
	-j

и его значение что бы пропустить пакеты(подходяшие под данное правило)
	ACCEPT

то же самое для цепочки OUTPUT, что бы пакеты ходили в оба направления
	sudo iptables -A OUTPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
	**************************************************************************************************
ПРОБЕЛЫ и их отсутствие важныв этих ебаныхкомандах!!!!!!!!!!!!!!!

конечно нужно установить правило для протокола ssh
	sudo iptables -A INPUT -p tcp -m conntrack --ctstate NEW -m tcp --dport 22 -j ACCEPT
	**********************************************************************************************************
мы разрешаем подключение именно к нашему серверо поэтому цепочка 
	INPUT
при помощи ключа 
	-p
мы указываем тип протокола
	tcp
этот ключ задает дополнительное условие	
	-m
это говорит то что мы пользуемся в данном правиле механизмом определения состояний
	conntrack

это ключ что-бы обозначить какие состояния нас интересуют
	--ctstate

так как в предыдушем правиле у нас есть разрешение для всех установленных соединени, то тут поставим состояние соединения (новое) 
	NEW

во втором дополнителном условии мы задали протокол и номер порта
	-m tcp --dport 22

пропускать пакеты поподающие под это правило	
	-j ACCEPT

Этих правил должно быть достаточно для работы данного сервака. Поэтому запретим весь остальной трафик. Для этого сначала сохраним измениения, соответственно для чего - зайдем под рутом
	su
	***
попросит ввести пароль для рута

потом само сохранение
	iptables-save > /etc/sysconfig/iptables
	************************************************

Ранее мы заметели, что политики по умалчанию ACCEPT, т.е. разрешено все пропускать. Поменяем эту политику на DROP, т.е все запрещено
	sudo iptables -P INPUT DROP
	***********************************
этот ключ говорит установить действие по умолчанию.
	-P 
для цепочки
	INPUT
все запретить
	DROP

аналогично поставим запрешаюшие политики для цепочек OUTPUT и FORWARD
	sudo iptables -P OUTPUT DROP
	**************************************
	sudo iptables -P FORWARD DROP
	***************************************
попингуем ....(самое главное чтобы pytty не отваоилось)
предворительно зайти под рутом через команду 
	su
	**
если все норм сохраняем в файл
	iptables-save > /etc/sysconfig/iptables
	************************************************

теперь настроим доступ для сегмента пользователей
	sudo iptables -t nat -A POSTROUTING -o enp0s3 -s 192.168.252.0/24 -j MASQUERADE
	********************************************************************************************************
указываем таблицу nat
	-t nat
затем указываем цепочку(нам нужно подменять адресс на выходе по этому цепочка POSTROUTING)
	-A POSTROUTING
затем указываем интерфейс при прохождении через который надо подменять адрес(было сказано трафик?)
	-o enp0s3
ключом -s указываем сеть источника трафика
	-s 192.168.252.0/24
действие -j MASQUERADE говорит что адресс источника нужно подменить адресом нашего шлюза/сервера(маршрутизатора)
	-j MASQUERADE
адрес источника будет подменятся адресом который назначен указанному (enp0s3) интерфейсу
и опять, предворительно зайти под рутом через команду 
	su
	**
если все норм сохраняем в файл правило
	iptables-save > /etc/sysconfig/iptables
	************************************************
мы добавили правило для подмены адреса в цепочку POSTROUTING, но до этой цепочки трафик не дойдет т.к. в предыдуших таблицах (FILTR) и цепочках FORWARD все запрешено(политика по умолчанию DROP). Исправим это
разрешим icmp(протокол пингов)для цепочки FORWARD
	sudo iptables -A FORWARD -p icmp -j ACCEPT
	*******************************************************
в правиле выше мы не указали интерфейс - это значит что правило работает для всех интерфейсов

Следушим правилам разрешим прохождение пакетов для уже установленных(ESTABLISHED) или связанных(RELATED) сессий, для цепочки FORWARD(более подробно синтаксис обьясняется выше для цепочки Input)
	sudo iptables -A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
	****************************************************************************************************


и разрешим сети пользователей открывать веб страницы	
	sudo iptables -A FORWARD -s 192.168.252.0/24 -p tcp -m conntrack --ctstate NEW -m multiport --dports 80,443 -j ACCEPT
	*****************************************************************************************************************************************************
мы указали что правило применяется для сети
	-s 192.168.252.0/24
для новых соединений
	-m conntrack --ctstate NEW 
и задали еще одно условие multiport, т.е. правило применяется для нескольких портов(в данном случае для портов 80-http, 443-https). Заметим что при указании нескольких портов ключ --dport пишется - --dports. Без запятой между портами!
	-m multiport --dports 80,443

что-бы пользовательская машина могла обращаться к DNS серверу и получать от него ответы нужно разрешить трафик по 53 порту.Разрешим его для протоколов TCP и UDP
	sudo iptables -A FORWARD -p tcp -m conntrack --ctstate NEW -m tcp --dport 53 -j ACCEPT
	sudo iptables -A FORWARD -p udp -m conntrack --ctstate NEW -m udp --dport 53 -j ACCEPT
не забываем сохранить правила. Можно проверить, что все изменения сохранились в файл
	sudo nano /etc/sysconfig/iptables
	*****************************************

что бы межсетевой экран включался при запуске системы его нужно добавить в автозагрузку. В centos7 для этого используется утилита systemctl
	sudo systemctl enable iptables
	**************************************
перезагрузим сервер
	reboot
	********

и проверим наши изменения в фаерволе
	sudo iptables -L -v -n
	**************************








*********************************************************************
*********************************************************************
**************************DHCP сервер***************************
*********************************************************************
*********************************************************************
сначала поменяем имя сервера чтобы вместо lokalhost введем нужное нам имя. Это можно сделать через файл, а можно воспользоваться утилитой nmcli. Введем команду
	sudo nmcli general hostname fw.netskills
	**************************************************
	fw -имя
	netskills -домен
чтобы убедиться, что имя изменилось достаточно переподключиться к серверу

теперь приступим к установке dhcp сервера. Что бы узнать как называется пакет с DHCP сервером воспользуемся поиском пакетного менеджера
	sudo yum search dhcp
нам,хрен знает почему(по описанию, все остальные это утилиты, библиотеки и заголовочные файлы), подойдет вот этот пакет
	dhcp.x86_64 : Dynamic host configuration protocol software
	.........................................................................
установим командой
	sudo yum install dhcp
	**************************
если вылезет ошибка типа
	could not resolve host: mirror.vilkam.ru; Unknown error
	--------------------------------------------------------------------
это говорит о том что не удалось преобразовать имя hosta в ip адрес. за это отвечает dnc сервер. Проверим 'резолвится'(преобразуется в ip) ли имя yandex.ru с нашего сервера
	nslookup ya.ru
	******************
если увидим ip аддреса yandex, то значит с dnc все норм. А если увидим типа
	connection timed out; trying next origin
	------------------------------------------------
это значит dnc сервер не работает. зайдем в /etc/resolv.conf
	sudo nano /etc/resolv.conf
	********************************
и проверим указанны ли там dnc сервера. если указанны выглядит примерно вот так
# Generated by NetworkManager
search netskills
nameserver 8.8.8.8
nameserver 8.8.4.4
если не указанныто можно указать через утилиту nmcli
	sudo nmcli c mod enp0s3 ipv4.dns "8.8.8.8"
	****************************************************
после этого перезапустим сетевую службу
	sudo systemctl restart network
	**************************************
Кстати... на мой взгляд сетевые настройки все равно проще всего менять в файле /etc/sysconfig/network-scripts/fcfg-enp0s3(fcfg-enp0s3 - это имя интерфейсаоно может быть другим, но как правило, формат примерно, такой)

После установки dhcp сервера перед тем как его запустить нам нужно его настроить. Перейдем к его настройке. Конфигурационные файлы dhcp сервера лежат в /etc/dhcp/
есть очень удобная штука - запуск файлового менеджера от имени администратора!!!!!!!!!!!
	sudo mc
	**********
теперь файловым менеджером зайдем по нашему адресу 
	/etc/dhcp/
	-------------
тут мы увидим конфигурационные файлы
	dhcp.conf
	dhcpd6.conf
соответственно первый для ip v4, второйдля ip v6; мы работаем только с v4 поэтому заходим 
dhcp.conf (почему то nano открывает этот файл и он пустой, а mc редактор видит что в нем есть)

#
# DHCP Server Configuration file.
#   see /usr/share/doc/dhcp*/dhcpd.conf.example
#   see dhcpd.conf(5) man page
#
в этом файле мы видим что можно воспользоваться помощью через команду man, или  посмотреть пример настройки  в файле по адресу /usr/share/doc/dhcp*/dhcpd.conf.example
Скопируем весь 
	dhcpd.conf.example 
файл в папку
	/etc/dhcp/
и обзавем его 
	dhcp.conf
то-есть мы заменили содержимое файла
	/etc/dhcp/dhcp.conf
на содержимое файла с примером настройки
	/usr/share/doc/dhcp*/dhcpd.conf.example
Все это я проделал из MC
			(переименовать файл в MC shift+f6
			копировать - зажатой shift выделить и не 
			отпуская кликнуть левой
			вставить  с зажатой shifе кликнуть правой)

теперь откроем файл
в этой строчке имя домена заменим на наше netskills
	option domain-name "example.oкg";
	-------------------------------------------
	option domain-name "netskills";
	---------------------------------------

в этой строчке прописываются dns сервера
	option domain-name-servers ns1.example.org, ns2.example.org;
	------------------------------------------------------------------------------
я указал ip роутера(для примера) или гугловский
	option domain-name-servers 192.168.190.86;
	-------------------------------------------------------
дальше две строки
	default-lease-time 600;
	max-lease-time 7200;
	---------------------------
дефолтное время аренды ip и максимальное время. Эти строки не трогаем

Заметим что есть строки которые начинаются с 
	option
это те строки значения которых передаются хосту-клиенту. те строки котроые не начинаются с этого слова это строки настроек самого DHCP сервера

эти три строчки для логирования . первые две которые закоментины - это описание. Третья - управляющая 
	# Use this to send dhcp log messages to a different log file (you also
	# have to hack syslog.conf to complete the redirection).
	log-facility local7;
тут сказано что необходимо подправить файл syslog.conf(потом подправим)

ниже идут настройки для нескольки подсетей(пока их закоментим т.к пока настраиваем одну сеть)
	subnet 10.152.187.0 netmask 255.255.255.0 {
	}

	# This is a very basic subnet declaration.

	subnet 10.254.239.0 netmask 255.255.255.224 {
  	range 10.254.239.10 10.254.239.20;
  	option routers rtr-239-0-1.example.org, rtr-239-0-2.example.org;
	}
	--------------------------------------------------------------------------------
закоментим это перед каждой строчкой поставим #

А пример ниже нам подойдет для настройки
	# A slightly different configuration for an internal subnet.
	subnet 10.5.5.0 netmask 255.255.255.224 {
	range 10.5.5.26 10.5.5.30;
  	option domain-name-servers ns1.internal.example.org;
  	option domain-name "internal.example.org";
  	option routers 10.5.5.1;
  	option broadcast-address 10.5.5.31;
  	default-lease-time 600;
  	max-lease-time 7200;
}

первая строчка это пояснение - заменим на свое, не раскоменчивая
	# user subnet configuration.










